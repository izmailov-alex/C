# Shell
***
### Описание
Интерпретатор команд shell — это (интерактивная) программа, воспринимающая и выполняющая команды, вводимые пользователем с терминала или находящиеся в командном файле (т.е. текстовом файле, содержащем последовательность команд). Команды делятся на «внутренние», которые shell выполняет непосредственно, и «внешние», для выполнения которых создаются отдельные процессы. Имя любого исполняемого файла Unix является «внешней» командой shell. Кроме того, shell позволяет соединять выполняющиеся команды каналами (создавать «конвейер»), перенаправлять ввод-вывод команд в файлы, выполнять команды в асинхронном режиме. Интерпретатор должен выдавать приглашение на ввод очередной команды, например “=> ” или “$ ”. При наступлении ситуации «конец файла» (Ctrl- D при вводе с клавиатуры) интерпретатор завершается.
***
### Реализованы следующие возможности:
1. Реализовано разбитие слов на лексемы: слова и специальные символы
2. Реализована команда cd
3. Реализована обработка кавычек
4. Реализована обработка комментариев
5. Реализовано экранирование символов
6. Релизовано последовательное выполнение команд
7. Реализован конвеер команд
8. Реализовано фоновое выполнение команд
9. Реализовано перенаправление потоков
10. Реализованы логические операции выполнения команд
***
### Программа работает на следующих тестах:

• cd ..
pwd
Перейти в родительскую директорию, напечатать ее название

• echo homedir: \$HOME username: $USER
Напечатать имя домашней директории и имя пользвателя

• cd
pwd
Перейти по умолчанию в домашнюю директорию. Убедиться, что попали туда

• pwd > fpwd
имя текущей директории записывается в файл fpwd

• who >> fpwd
имя пользователя добавляется в конец файла fpwd

• cat <file.in> file.out
Копирует содержимое файла file.in в file.out.

• cat < file.in >> file.out
Дописывает содержимое файла file.in в конец file.out.

• zcat < file.tar.gz | tar -xv
Распаковывает .tar.gz архив.

• cat < /dev/urandom | head -c 4096 > "file.bin"
Создаёт файл случайных чисел размером 4096 байт.

• yes | head
Печатает 10 раз букву y.

• yes | yes | yes | yes | yes | yes | yes | yes | head
Печатает 10 раз букву y. Проследить с помощью ps или top из другого окна xterm,чтобы не оставались зомби

• cat < /dev/null | head | head | head | head | head
Ничего не печатает. Проследить с помощью ps или top из другого окна xterm, чтобы не оставались зомби

• pwd > current_dir.txt
Печатает текущую директорию в файл current_dir.txt.

• pwd | cat >> my_home.txt
Дописывает домашнюю директорию пользователя в файл my_home.txt.

• ls | cat | cat | cat | cat
Печатает список файлов текущей директории на стандартный вывод.

• who | cat > who_am_i.txt | cat | cat | cat > who_am_i_not.txt
Печатает имя пользователя в файл who_am_i.txt. Файл who_am_i_not.txt создаётся и оказывается
пустым.

• yes | yes | yes | yes | sleep 10 | pwd
Печатает текущую директорию. Проследить, чтобы приглашение к следующей команде появилось не
раньше, чем через 10 сек.
Выводит пронумерованные строки, введенные с клавиатуры, и отсортированные в обратном порядке

• cat | sort –r | cat –n
Печатает вводимые строки, отсортированные в обратном порядке и пронумерованные

• pwd; pwd | cd..| wc ; pwd
Печатает одно и то же имя директории – внутри конвейера cd игнорируется, аналогичное поведение для
exit и других внутренних команд. В конвейере они игнорируются.

• pwd | exit | date | cat
Печатает только текущую дату.

• sleep 10; pwd
Директория печатается через 10 сек

• sleep 10 & pwd
Директория печатается сразу
Проверить, что не остается зомби от фонового процесса sleep 10 &

• sleep 5 & sleep 5 & sleep 5 & sleep 5 & sleep 5 &
Проверить зомби (с помощью команды ps или top)

• sleep 5 &
sleep 5 # набирать эту команду быстро
ps
Проверить зомби (с помощью команды ps или top)

• echo a b c > f; cat f & ls
• echo a b c > f; echo >> f; cat<f
• cat f; date; pwd > zz
• ls && date && pwd
• ls || date || pwd
• pwd && sleep 5 &
***
### Файлы:
* main.c - запускающий файл
* func.c - файл со всеми функциями
* lgragh.c - файл с L-графом, который обрабатывает лексемы
* Для запуска напишите make и запустите ./myShell
***
###Функции обрабатывающие слова:
```
int construct()
-запускает программу

void null_list(char **mass, int *sizelist, int *curlist)
-инициализирует список mass
-обнуляет размер списка sizelist
-обнуляет счетчик текущего свободного элемента curlist

void clearlist(char **mass, int *sizelist, int *curlist)
-Очищает список mass
-Обнуляет счетчики sizelist и  curlist

void termlist(char ***mass, int *sizelist, int *curlist)
-Корректирует размер списка mass
-Корректирует счетчики списка sizelist и curlist

void printlist(char ***mass, int *sizelist)
-Печатает список mass

void sortlist(char ***mass, int *sizelist)
-Сортирует в лексикографическом порядке список mass

void null_buf(char *buf, int *sizebuf, int *curbuf)
-Очищает буфер buf

void addsym(int c, char **buf, int *sizebuf, int *curbuf)
-Добавляет символ с в буфер buf
-Меняет счетчики буфера sizebuf и curbuf

int check1(int c)
-Проверяет символ с на то специальный он или нет

int check2(int c)
-Проверяет символ с на повторяющиеся специальные символы

int symset(int c)
-проверяет символ с на непечатающиеся символы

void addword(char **buf, int *sizebuf, int *curbuf, char ***mass, int *sizelist, int *curlist)
-Добавляет в список mass, слово из buf
-Обновляет счетчики буфера и списка

int upd(int *curinp, char *inp)
-Обновляет буфер ввода inp
-Обновляет счетчик ввода curinp

int getsym(int *curinp, char *inp)
-Возвращает считанный символ из буфера inp
-Обновляет счетчик ввода curinp
```

### Функции и структуры для обработки процессов:
```
Структура данных для создания команд
typedef struct cmd_inf {
    char ** argv; // список из имени команды и аргументов
    char *infile; // переназначенный файл стандартного ввода
    char *outfile; // переназначенный файл стандартного вывода
    int backgrnd; // =1, если команда подлежит выполнению в фоновом режиме
    struct cmd_inf* psubcmd; // команды для запуска в дочернем shell
    struct cmd_inf* pipe; // следующая команда после “|”
    struct cmd_inf* next; // следующая после “;” (или после “&”)
    int flag1;  // флаг это 1 - ";" , 2 - "&" , 3 - "&&", 4 - "||", 5 - ">", 6 - "<", 7 - ">>", 8 - "<<", 9 - "|"
    int flag2; //если flag1 занят, то следующий специальный символ заносится в flag2
} cmd;

void printfstruct(cmd *com)
-Печать структуры команды

void analysis(char **lex, int curlen)
-Создает команды и заполняет их лексемами

int check(char *s)
-Проверка на специальный символ

cmd* creatcom(void)
-Возвращает ссылку на структуру хранящую информацию о команде

void set_back(cmd *list)
-Устанавливает в структурах флаг внешнего процесса

void back_pipe(cmd *curr)
-Устанавливает флаг внешнего процесса в конвеер

void substitution(cmd *command, char **mass)
-Заменяет подстановки $HOME, $SHELL, $USER, $EUID

int process(cmd *command)
-Запускает выполнение программ
Возвращает 0 в случае успеха.

int outfile(cmd *command)
-Подключение файла вывода

int infile(cmd *command)
-Подключение файла ввода

void cmdcd(int argc, char ** argv)
-Реализация команды cd

cmd* conveer(cmd *command)
-Реализация конвеера команд

cmd* cmdnext(cmd *command)
-Реализация последовательного выполнения команд с поддержкой логический операций && и ||

int checkend(int status)
-Проверка статуса завершения команды

void addprocess(int pid, cmd* command)
-Добавляет процесс в таблицу процессов

void cleanprocess()
-Очистка таблицы процессов

void hunt()
-Завершает внешние процессы

void updateback()
-Обновление таблицы внешних процессов

void clearcmd(cmd *command)
-Очищение структур команд

void final_clean()
-Финальная очистка процессов
```